[{"path":"https://jvparidon.github.io/lmerMultiMember/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 lmerMultiMember authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"off-label-usage-of-lmermultimember","dir":"Articles","previous_headings":"","what":"Off-label usage of lmerMultiMember","title":"Bradley-Terry models in lmerMultiMember","text":"ability pass arbitrary random effects matrices lme4 makes lmerMultiMember useful just vanilla multiple membership models. model can specified combination “conventional” fixed effects arbitrary random effects matrix can specified using lmerMultiMember. (Although certain model specifications underlying lme4 model fitting may converge.) One class models can fit using lmerMultiMember Bradley-Terry models, used predict probability given individual winning paired comparison another individual, even information incomplete (.e. every individual directly encountered every individual). One fairly prominent application predict rankings chess players, even every player list played every player. Bradley-Terry model can written Generalized Linear Mixed-effects Model (GLMM) follows: \\[\\operatorname{logit}(P(> j)) = \\log\\left(\\frac{P(> j)}{1 - P(> j)}\\right) = \\log\\left(\\frac{P(> j)}{P(j > )}\\right) = \\beta_i - \\beta_j\\] ’re comfortable math, don’t worry! formulation Bradley-Terry model just logistic regression random effects matrix usual positive indicators one individual comparison, negative indicators individual. formulation model probability individual positive indicator “wins” comparison. often natural way assign individuals sides comparison, instance always giving home team positive indicator (case, model intercept, intercept represents home field advantage) , chess, always assign player white pieces positive indicator. lmerMultiMember::bradleyterry_from_vectors() helper function creates indicator matrix vector home teams (.e. individuals assigned positive indicators) vector visiting teams (.e. individuals assigned negative indicators). function used generate indicator matrix, modeling probability home team winning.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"predicting-nfl-team-rankings-for-the-2021-season","dir":"Articles","previous_headings":"","what":"Predicting NFL team rankings for the 2021 season","title":"Bradley-Terry models in lmerMultiMember","text":"demonstrate specify fit Bradley-Terry model lmerMultiMember, vignette rank National Football League teams performance 2021 season. course know “won” season, Los Angeles Rams won Super Bowl end playoffs. However, Bradley-Terry model, can predict win probabilities even teams play single game season. example, might wondering local team, Green Bay Packers, fared spouse’s home team, Los Angeles Chargers (formerly San Diego), even though teams different conferences play 2021 season. ’ll demonstrate vignette, coefficients Bradley-Terry model can give predicted outcome hypothetical game. NFL scores 2021 season included lmerMultiMember dataset, need load data load package . , can take quick look data.","code":"# load packages library(lmerMultiMember)  # for dataset and modeling library(kableExtra)  # for displaying tabular data library(dplyr)  # for data manipulation library(sjPlot)  # for plotting model coefficients library(ggplot2)  # for general plotting stuff  # display the NFL 2021 season data nfl_scores_2021 |>   kable() |>   kable_styling(bootstrap_options = c(\"hover\", \"condensed\"), font_size = 16) |>   scroll_box(height = \"250px\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"generating-a-bradley-terry-indicator-matrix-and-fitting-a-model","dir":"Articles","previous_headings":"","what":"Generating a Bradley-Terry indicator matrix and fitting a model","title":"Bradley-Terry models in lmerMultiMember","text":"dataset can generate Bradley-Terry indicator matrix using lmerMultiMember::bradleyterry_from_vectors(). indicator matrix generated, need specify logistic glmer() model predict wins home team, insert indicator model using dummy variable.","code":"# generate indicator matrix from home team and visiting team vectors W <- bradleyterry_from_vectors(nfl_scores_2021$home_team,                                nfl_scores_2021$visiting_team)  # check dimensions of indicator matrix (should be teams x games) # i.e. 32 x 285 paste(c(\"rows/teams:\", \", columns/games:\"), dim(W)) |> cat() ## rows/teams: 32 , columns/games: 285 # convert winners to binary variable for more transparent interpretation nfl_scores_2021$home_win <- recode(nfl_scores_2021$winner,                                    \"visiting\" = 0, \"home\" = 1)  # fit model m <- glmer(home_win ~ (1 | indicators),            family = binomial,            memberships = list(indicators = W),            data = nfl_scores_2021)  # show model summary summary(m) ## Generalized linear mixed model fit by maximum likelihood (Laplace ##   Approximation). Model includes multiple membership random effects. [ ## glmerModMultiMember] ##  Family: binomial  ( logit ) ## Formula: home_win ~ (1 | indicators) ##    Data: nfl_scores_2021 ##  ##      AIC      BIC   logLik deviance df.resid  ##    390.2    397.5   -193.1    386.2      283  ##  ## Scaled residuals:  ##     Min      1Q  Median      3Q     Max  ## -1.6333 -0.9093  0.5800  0.8542  1.6139  ##  ## Random effects: ##  Groups     Name        Variance Std.Dev. ##  indicators (Intercept) 0.2554   0.5054   ## Number of obs: 285, groups:  indicators, 32 ##  ## Fixed effects: ##             Estimate Std. Error z value Pr(>|z|) ## (Intercept)  0.06406    0.12565    0.51     0.61 ##  ## Group memberships per observation for multiple membership REs: ##            Min. per obs. Mean per obs. Max. per obs. ## indicators 0             0             0"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"sanity-check-on-random-intercepts-team-strength","dir":"Articles","previous_headings":"","what":"Sanity check on random intercepts (team strength)","title":"Bradley-Terry models in lmerMultiMember","text":"model fit, can start interpreting coefficients. intercept model represents home field advantage (.e. probability home team winning, regardless team’s strength). strength individual teams captured random intercepts.  model predicts scale logits (log-odds), sjPlot automatically transforms coefficients odds ratios exponentiating . fairly natural way interpreting coefficients model like , let’s take look best worst teams. Los Angeles Rams, team highest random intercept, odds ratio almost 2, meaning favored 2:1 win hypothetical average team League. Rams eventual Super Bowl winners 2021, seems like sensible model prediction, least superficially. Jacksonville Jaguars, team lowest random intercept, odds ratio .5, meaning odds beating hypothetical League average team 1:2, consistent League-worst 3-14 win/loss record.","code":"# plot random effects plot_model(m, type = \"re\", sort.est = TRUE, grid = FALSE,            line.size = 1.0, dot.size = 3.0) +   coord_cartesian() +   theme_bw() +   ggtitle(\"Odds ratio of team winning against League-average team\") +   theme(axis.ticks = element_blank(),         axis.text.x = element_text(size = 12, angle = 60, hjust = 1.0),         axis.text.y = element_text(size = 12),         plot.title = element_text(size = 14),         rect = element_rect(fill = \"transparent\")) +   scale_y_continuous() +   geom_hline(yintercept = 1.0, color = \"coral2\", size = 1.0) +   scale_color_manual(values = c(\"coral3\", \"coral1\"))"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"predicting-the-winner-of-an-unplayed-game","dir":"Articles","previous_headings":"","what":"Predicting the winner of an unplayed game","title":"Bradley-Terry models in lmerMultiMember","text":"far, good; model correctly predicted League’s best worst teams 2021 season. hypothetical matchup, LA Chargers playing Green Bay Packers? ’s easiest understand make prediction compute hand. start looking random intercepts Packers (GB) Chargers (LAC). exponentiating difference intercepts, can compute odds ratio favor Green Bay winning hypothetical matchup. \\[(GB > LAC) = \\exp(\\beta_{GB} - \\beta_{LAC}) = \\exp(.50 - .07) = 1.54\\] odds 2021 Packers winning 2021 Chargers, disregarding potential home field advantage, 1.54:1.","code":"# extract random intercepts for Green Bay and the LA Chargers ranef(m)$indicators[c(\"GB\", \"LAC\"), , drop = FALSE] |> round(2) ##     (Intercept) ## GB         0.50 ## LAC        0.07"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/bradleyterry_models.html","id":"replicating-the-bradley-terry-model-in-stan","dir":"Articles","previous_headings":"","what":"Replicating the Bradley-Terry model in Stan","title":"Bradley-Terry models in lmerMultiMember","text":"double-check predictions got lmerMultiMember, can fit model structure Stan, probabilistic programming language Bayesian models. Replicating model Bayesian framework convenient, can reproduce mild shrinkage lme4 applies random effects. (can approximate implicit uniform prior home field advantage lmerMultiMember putting wide prior coefficient Stan model.) first specify Stan model’s structure: , pass data model sample using rstan. Conveniently, can use helper function lmerMultiMember::bradleyterry_from_vectors() generate indicator matrix Stan, well: Finally, can plot HDIs posterior samples manner plotted lmerMultiMember effects:  rstan lmerMultiMember estimates team strength seem match, although uncertainty intervals little bit wider . (potentially fixed setting stricter priors.)","code":"data {   int<lower=1> N;  // number of games   int<lower=1> M;  // number of teams   matrix[N, M] W;  // indicator matrix   int<lower=0> home_win[N];  // outcome } parameters {   real home_adv;  // home field advantage   vector[M] team_logOR;  // team strength (log odds ratio)   real<lower=0> sigma;  // sd of team strengths } transformed parameters {   vector[M] team_OR;  // odds ratio per team   team_OR = exp(team_logOR);  // exponentiate team log OR } model {   home_adv ~ normal(0, 100);  // wide normal prior on home field advantage   team_logOR ~ normal(0, sigma);  // normal priors on team strength   home_win ~ bernoulli_logit(home_adv + W * team_logOR);  // likelihood } # use multiple cores for sampling options(mc.cores = parallel::detectCores())  # prepare data for passing to Stan sampler stan_data <- list(   home_win = nfl_scores_2021$home_win,   N = nrow(nfl_scores_2021),   M = length(unique(nfl_scores_2021$home_team)),   W = t(as.matrix(bradleyterry_from_vectors(nfl_scores_2021$home_team,                                             nfl_scores_2021$visiting_team))) )  # sample from Stan model stan_fit <- rstan::sampling(model_stan, data = stan_data,                                warmup = 2000, iter = 8000)  # create tidy data frame from posterior samples stan_post <- broom.mixed::tidy(stan_fit, pars = \"team_OR\", conf.int = TRUE)  # store fitted Stan model save(stan_post, file = \"bt_model_stan_fit.Rds\") # load fitted Stan model (this is to save resources when building vignettes) load(\"bt_model_stan_fit.Rds\")  # sort teams from low to high and color-code stan_post$term <- sort(unique(nfl_scores_2021$home_team)) stan_post$color <- cut(stan_post$estimate, breaks = c(0, 1, Inf),                   labels = c(\"negative\", \"positive\"))  # plot 95% HDIs stan_post[order(stan_post$estimate), ] |>   ggplot(aes(y = estimate, x = factor(term, level = term), color = color)) +   geom_point(size = 3) +   geom_linerange(aes(ymin = conf.low, ymax = conf.high,                      x = factor(term, level = term), color = color), size = 1) +   theme_bw() +   ggtitle(\"Odds ratio of team winning against League-average team\") +   theme(axis.ticks = element_blank(),         axis.text.x = element_text(size = 12, angle = 60, hjust = 1.0),         axis.text.y = element_text(size = 12),         plot.title = element_text(size = 14),         legend.position = \"none\",         rect = element_rect(fill = \"transparent\")) +   xlab(\"\") + ylab(\"\") +   geom_hline(yintercept = 1.0, color = \"coral2\", size = 1.0) +   scale_color_manual(values = c(\"coral3\", \"coral1\"))"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"what-is-the-difference-between-crossed-random-effects-and-multiple-membership-random-effects","dir":"Articles","previous_headings":"","what":"What is the difference between crossed random effects and multiple membership random effects?","title":"Frequently Asked Questions","text":"Multiple membership crossed random effects: crossed random effects model, observation can associated single level multiple, independent random effects (.e. random effects nested). multiple membership model, observation can associated multiple levels single random effect. lme4 supports fully crossed random effects (whereas e.g. nlme ), multiple membership models. lmerMultiMember adds support multiple membership models lme4, addition existing support fully crossed random effects.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"what-are-multiple-membership-models-used-for","dir":"Articles","previous_headings":"","what":"What are multiple membership models used for?","title":"Frequently Asked Questions","text":"general, multiple memberships models useful observation data associated just single participant/patient/etc. multiple participants variable compositions. One example team sports, team’s performance attributable input multiple players, players team starts given game may variable. derive measure individual athlete’s performance, ’ll need model multiple membership structure. Another example psychological experiments involve multiple people interacting (e.g. iterated learning experiments). outcome interaction depends input multiple participants, unless strict role assignment (e.g. one participant can talk, can listen) makes sense model participant random effects using multiple membership. lmerMultiMember pretty new, ’ve already heard researchers various fields ’re using extend lme4 can model data requires multiple membership models. marine ecology, used model species diversity California coast, modeling health outcomes patients multiple comorbidities, modeling genomic data, lead authors’ work experimental psychology. ’re using lmerMultiMember model something new exciting, let us know!","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"lmermultimember-assumes-that-levels-of-a-random-effect-are-additive-but-what-if-i-dont-want-to-make-that-assumption","dir":"Articles","previous_headings":"","what":"lmerMultiMember assumes that levels of a random effect are additive, but what if I don’t want to make that assumption?","title":"Frequently Asked Questions","text":"true lmerMultiMember assumes additive effects (e.g. relay race’s outcome determined sum individual runner’s speeds) assumption may hold whatever process trying model. assumptions additivity can built multiple membership model, point probably going need write custom Bayesian model e.g. Stan. think something need , recommend ) really think hard assumption (additivity pretty reasonable, make sure really need deviate ) B) send us email need help.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"lmermultimember-says-the-number-of-levels-in-my-grouping-factor-exceeds-the-number-of-observations","dir":"Articles","previous_headings":"","what":"lmerMultiMember says the number of levels in my grouping factor exceeds the number of observations!","title":"Frequently Asked Questions","text":"hard fit random effects enough observations level random effect. lmerMultiMember requires least many observations levels random effect, absolute lower limit absolutely strive reliable estimation. lme4, need least many observations levels random effect hard technical/mathematical requirement. math behind lmerMultiMember makes technically possible fit models fewer observations levels random effect cases, determining lowest acceptable number observations given model trivial, now simply using rule lme4 uses convenience.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"i-tried-using-another-package-to-plotsummarizeetc--an-lmermultimember-model-but-i-got-an-error","dir":"Articles","previous_headings":"","what":"I tried using another package to plot/summarize/etc. an lmerMultiMember model, but I got an error!","title":"Frequently Asked Questions","text":"Since lmerMultiMember model objects behave much like lme4 model objects (“inherit” model class lme4) can generally use use lme4 model. However, packages (e.g. sjPlot) strict recognizing models sometimes reject lmerMultiMember models throwing error. Luckily, easy workaround often successful, coerce lmerMultiMember model object class lme4 lmerTest model: Keep mind change just trick; superficial change packages may still throw errors. happens, please help us help reporting issue lmerMultiMember Github repo, take look see can fix /convince author package add support lmerMultiMember.","code":"class(m_lmer) <- \"lmerMod\"  # for lmer models class(m_glmer) <- \"glmerMod\"  # for glmer models class(m_lmer) <- \"lmerModLmerTest\"  # if you want to use lmerTest functionality"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"why-are-multiple-membership-models-not-part-of-lme4-already","dir":"Articles","previous_headings":"","what":"Why are multiple membership models not part of lme4 already?","title":"Frequently Asked Questions","text":"lme4 support multiple membership models originally less common use-case single membership models turns kind hard implement elegant way. combination issues probably makes hard justify things like changing lme4 syntax just support functionality. ’re pushing absorb lmerMultiMember lme4 either, latter kind maintenance mode stable, development focusing compatibility bugfixes, lmerMultiMember still little experimental might still undergo major changes.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/faq.html","id":"how-should-i-cite-lmermultimember","dir":"Articles","previous_headings":"","what":"How should I cite lmerMultiMember?","title":"Frequently Asked Questions","text":"appreciate citing lmerMultiMember ’re publishing research uses package. can find citation information author page.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/group_membership.html","id":"general-idea","dir":"Articles","previous_headings":"","what":"General idea","title":"Group membership models using lmerMultiMember","text":"Consider situation multiple items sort associated effects, can’t association observations single items; instead, observation associated group items. (Two examples come (1) authorship papers (2) hockey players team.) quite identical “multi-membership models” (part group membership binary, .e., weighted), although similar techniques shown work multi-membership models.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/group_membership.html","id":"simple-example","dir":"Articles","previous_headings":"","what":"Simple example","title":"Group membership models using lmerMultiMember","text":"Load packages (don’t really need anything beyond lmerMultiMember; rest convenience/drawing pictures). Construct simulated example: first, simulate design (structure).  can look many times particular number groups occurs (match \\(Binomial(n=20, 0, p=0.25)\\))  Since chose items/individuals include observation randomly independently (Bernoulli probability 0.25), highly variable number individuals present different observations (1-11). realistic examples (authorship), unrealistic others (hockey) … don’t think really makes much difference computationally (statistically, observations single member must make estimation powerful …) 0/1 matrix (indicator variable whether item \\(\\) included observation \\(j\\)) convenient, turn form need inclusion model. fairly straightforward convert forms (e.g. list sets items associated observation) form … Now simulate response variable. Fit results look OK (correct item residual variance estimated): conditional modes item look good:","code":"library(lmerMultiMember) library(broom.mixed) library(ggplot2) theme_set(theme_bw()) library(Matrix) nm <- 20 # number of groups nobs <- 1000 set.seed(101) ## choose items for observations pres <- matrix(rbinom(nobs * nm, prob = 0.25, size = 1), nrow = nobs, ncol = nm) dimnames(pres) <- list(NULL, LETTERS[seq(nm)]) pres[1:5, ] ##      A B C D E F G H I J K L M N O P Q R S T ## [1,] 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 1 1 0 0 0 ## [2,] 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 ## [3,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 ## [4,] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 1 0 0 ## [5,] 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 image(Matrix(pres),   ylim = c(1, 10), sub = \"\", ylab = \"Observation\",   xlab = \"Item\",   ## draw tick labels at top   scales = list(at = 1:20, x = list(     labels = colnames(pres),     alternating = 2   )) ) hist(rowSums(pres),   main = \"Multi-Group Membership\",   xlab = \"Number of groups associated with an observation\" ) b <- rnorm(nm, sd = 2) ## item-level effects ## n.b. get in trouble if we don't add residual error ## (theta is scaled relative to residual error) y <- c(pres %*% b) + rnorm(nobs, sd = 1.5) m1 <- lmer(y ~ 1 + (1 | membership),   data = data.frame(y = y, x = rep(1, nobs)),   memberships = list(membership = t(pres)) ) summary(m1) ## Linear mixed model fit by REML. Model includes multiple membership random ##   effects. [lmerModMultiMember] ## Formula: y ~ 1 + (1 | membership) ##    Data: data.frame(y = y, x = rep(1, nobs)) ##  ## REML criterion at convergence: 3649.6 ##  ## Scaled residuals:  ##     Min      1Q  Median      3Q     Max  ## -3.1676 -0.6347 -0.0237  0.6569  3.3445  ##  ## Random effects: ##  Groups     Name        Variance Std.Dev. ##  membership (Intercept) 3.840    1.960    ##  Residual               1.995    1.412    ## Number of obs: 1000, groups:  membership, 20 ##  ## Fixed effects: ##             Estimate Std. Error t value ## (Intercept)   0.1618     0.1320   1.226 ##  ## Group memberships per observation for multiple membership REs: ##            Min. per obs. Mean per obs. Max. per obs. ## membership 0             5.067         14 dd <- tidy(m1, effects = \"ran_vals\") dd <- transform(dd, level = reorder(level, estimate)) truth <- data.frame(level = LETTERS[seq(nm)], estimate = b) ggplot(dd, aes(x = level, y = estimate)) +   geom_pointrange(aes(     ymin = estimate - 2 * std.error,     ymax = estimate + 2 * std.error   )) +   coord_flip() +   geom_point(data = truth, colour = \"red\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/group_membership.html","id":"zooming-in-equal-indepent-contributions","dir":"Articles","previous_headings":"","what":"Zooming In: Equal, indepent contributions","title":"Group membership models using lmerMultiMember","text":", look model observation associated precisely two groups get better feel.  ideal, horrible – looks like upward bias, inline estimate group standard deviation bit .","code":"set.seed(42) nobs <- 1000 nm <- 10 dat <- data.frame(   x = runif(nobs),   z = runif(nobs),   # TODO: double check that all(g1 != g2)   g1 = sample(1:nm, nobs, TRUE),   g2 = sample(1:nm, nobs, TRUE) )  dat$grps <- paste(LETTERS[dat$g1], LETTERS[dat$g2], sep = \",\")  # fixed effects beta <- c(1, 2, 3) # random effects bint <- rnorm(nm, sd = 3.14) # we could be clever about setting the model matrix here, but it's # easier and clearer how we're constructing bits if we're inefficient  fe <- beta[1] + beta[2] * dat$x + beta[3] * dat$z  # note that the group contributions for each observation are assumed to be # independent and equally weighted. # TODO: add example of unequal weights re <- bint[dat$g1] + bint[dat$g2]  dat$y <- fe + re + rnorm(nobs, sd = 1) weights <- weights_from_vector(dat$grps) head(dat) ##           x          z g1 g2 grps         y ## 1 0.9148060 0.84829322  2  9  B,I  7.132846 ## 2 0.9370754 0.06274633  4 10  D,J -1.199958 ## 3 0.2861395 0.81984509  7  4  G,D  1.939330 ## 4 0.8304476 0.53936029  3  7  C,G  3.706502 ## 5 0.6417455 0.49902010 10 10  J,J -1.075549 ## 6 0.5190959 0.02222732 10  9  J,I  1.807260 image(t(weights),   ylim = c(1, 10), sub = \"\", ylab = \"Observation\",   xlab = \"Item\",   ## draw tick labels at top   scales = list(at = 1:20, x = list(     labels = colnames(pres),     alternating = 2   )) ) m2 <- lmer(y ~ 1 + x + z + (1 | g),   data = dat,   memberships = list(g = weights), REML = FALSE ) summary(m2) ## Linear mixed model fit by maximum likelihood . Model includes multiple ##   membership random effects. [lmerModMultiMember] ## Formula: y ~ 1 + x + z + (1 | g) ##    Data: dat ##  ##      AIC      BIC   logLik deviance df.resid  ##   2985.4   3009.9  -1487.7   2975.4      995  ##  ## Scaled residuals:  ##      Min       1Q   Median       3Q      Max  ## -2.94604 -0.65151  0.00031  0.66380  3.15347  ##  ## Random effects: ##  Groups   Name        Variance Std.Dev. ##  g        (Intercept) 12.644   3.556    ##  Residual              1.061   1.030    ## Number of obs: 1000, groups:  g, 10 ##  ## Fixed effects: ##             Estimate Std. Error t value ## (Intercept)  -1.2482     2.2505  -0.555 ## x             1.8539     0.1125  16.474 ## z             2.9098     0.1106  26.307 ##  ## Correlation of Fixed Effects: ##   (Intr) x      ## x -0.024        ## z -0.024 -0.001 ##  ## Group memberships per observation for multiple membership REs: ##   Min. per obs. Mean per obs. Max. per obs. ## g 2             2             2 dd <- tidy(m2, effects = \"ran_vals\") dd <- transform(dd, level = reorder(level, estimate)) truth <- data.frame(level = LETTERS[seq(nm)], estimate = bint) ggplot(dd, aes(x = level, y = estimate)) +   geom_pointrange(aes(     ymin = estimate - 2 * std.error,     ymax = estimate + 2 * std.error   )) +   coord_flip() +   geom_point(data = truth, colour = \"red\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/group_membership.html","id":"a-slightly-more-complex-example","dir":"Articles","previous_headings":"","what":"A slightly more complex example","title":"Group membership models using lmerMultiMember","text":"build last example adding random slope.","code":"set.seed(42) nobs <- 10000 nm <- 26 dat <- data.frame(   x = runif(nobs),   z = runif(nobs),   # TODO: double check that all(g1 != g2)   g1 = sample(1:nm, nobs, TRUE),   g2 = sample(1:nm, nobs, TRUE) )  dat$grps <- paste(LETTERS[dat$g1], LETTERS[dat$g2], sep = \",\")  # fixed effects beta <- c(1, 2, 3) # random effects bint <- rnorm(nm, sd = 3.14) bx <- rnorm(nm, sd = 0.2)  # we could be clever about setting the model matrix here, but it's # easier and clearer how we're constructing bits if we're inefficient  fe <- beta[1] + beta[2] * dat$x + beta[3] * dat$z  # note that the group contributions for each observation are assumed to be # independent and equally weighted. # TODO: add example of unequal weights re <- bint[dat$g1] + bint[dat$g2] + (bx[dat$g1] + bx[dat$g2]) * dat$x  dat$y <- fe + re + rnorm(nobs, sd = 1) head(dat) ##           x         z g1 g2 grps         y ## 1 0.9148060 0.5283896 11 13  K,M 9.7194660 ## 2 0.9370754 0.6463879 24 12  X,L 4.9175119 ## 3 0.2861395 0.8340490 17  2  Q,B 0.3754283 ## 4 0.8304476 0.3457626 22 19  V,S 8.4488474 ## 5 0.6417455 0.6217329 25 20  Y,T 5.8487113 ## 6 0.5190959 0.6631953 23 10  W,J 9.5083034 image(t(weights_from_vector(dat$grps)),   ylim = c(1, 10), sub = \"\", ylab = \"Observation\",   xlab = \"Item\",   ## draw tick labels at top   scales = list(at = 1:20, x = list(     labels = colnames(pres),     alternating = 2   )) ) m3 <- lmer(y ~ 1 + x + z + (1 + x | g),   data = dat, REML = FALSE,   memberships = list(g = weights_from_vector(dat$grps)) ) summary(m3) ## Linear mixed model fit by maximum likelihood . Model includes multiple ##   membership random effects. [lmerModMultiMember] ## Formula: y ~ 1 + x + z + (1 + x | g) ##    Data: dat ##  ##      AIC      BIC   logLik deviance df.resid  ##  28687.9  28738.4 -14337.0  28673.9     9993  ##  ## Scaled residuals:  ##     Min      1Q  Median      3Q     Max  ## -3.5911 -0.6717 -0.0054  0.6643  3.8577  ##  ## Random effects: ##  Groups   Name        Variance Std.Dev. Corr ##  g        (Intercept) 9.8809   3.1434        ##           x           0.0354   0.1882   0.01 ##  Residual             1.0031   1.0015        ## Number of obs: 10000, groups:  g, 26 ##  ## Fixed effects: ##             Estimate Std. Error t value ## (Intercept)  3.12330    1.23322   2.533 ## x            2.08221    0.08148  25.553 ## z            3.01460    0.03466  86.967 ##  ## Correlation of Fixed Effects: ##   (Intr) x      ## x  0.005        ## z -0.014  0.000 ##  ## Group memberships per observation for multiple membership REs: ##   Min. per obs. Mean per obs. Max. per obs. ## g 2             2             2 dd <- tidy(m3, effects = \"ran_vals\") dd <- transform(dd, level = reorder(level, estimate)) truth <- rbind(   data.frame(level = LETTERS[seq(nm)], estimate = bint, term = \"(Intercept)\"),   data.frame(level = LETTERS[seq(nm)], estimate = bx, term = \"x\") ) ggplot(dd, aes(x = level, y = estimate)) +   geom_pointrange(aes(     ymin = estimate - 2 * std.error,     ymax = estimate + 2 * std.error   )) +   coord_flip() +   geom_point(data = truth, colour = \"red\") +   facet_wrap(~term) # note that we have a random slope for which we didn't introduce any variation # in the data, which is the same as setting it to zero m4 <- lmer(y ~ 1 + x + z + (1 + x + z | g),   data = dat, REML = FALSE,   memberships = list(g = weights_from_vector(dat$grps)) ) summary(m4) ## Linear mixed model fit by maximum likelihood . Model includes multiple ##   membership random effects. [lmerModMultiMember] ## Formula: y ~ 1 + x + z + (1 + x + z | g) ##    Data: dat ##  ##      AIC      BIC   logLik deviance df.resid  ##  28693.5  28765.6 -14336.7  28673.5     9990  ##  ## Scaled residuals:  ##     Min      1Q  Median      3Q     Max  ## -3.5946 -0.6727 -0.0037  0.6656  3.8513  ##  ## Random effects: ##  Groups   Name        Variance  Std.Dev. Corr        ##  g        (Intercept) 9.9323317 3.15156              ##           x           0.0354297 0.18823   0.01       ##           z           0.0002575 0.01605  -1.00  0.01 ##  Residual             1.0030416 1.00152              ## Number of obs: 10000, groups:  g, 26 ##  ## Fixed effects: ##             Estimate Std. Error t value ## (Intercept)  3.12317    1.23642   2.526 ## x            2.08243    0.08151  25.548 ## z            3.01462    0.03523  85.570 ##  ## Correlation of Fixed Effects: ##   (Intr) x      ## x  0.004        ## z -0.192  0.002 ##  ## Group memberships per observation for multiple membership REs: ##   Min. per obs. Mean per obs. Max. per obs. ## g 2             2             2 # note that we have a random slope for which we didn't introduce any variation # in the data, which is the same as setting it to zero m4zc <- lmer(y ~ 1 + x + z + (1 + x + z || g),   data = dat, REML = FALSE,   memberships = list(g = weights_from_vector(dat$grps)) ) summary(m4zc) ## Linear mixed model fit by maximum likelihood . Model includes multiple ##   membership random effects. [lmerModMultiMember] ## Formula: y ~ 1 + x + z + (1 + x + z || g) ##    Data: dat ##  ##      AIC      BIC   logLik deviance df.resid  ##  28687.9  28738.4 -14337.0  28673.9     9993  ##  ## Scaled residuals:  ##     Min      1Q  Median      3Q     Max  ## -3.5912 -0.6718 -0.0054  0.6645  3.8579  ##  ## Random effects: ##  Groups   Name        Variance Std.Dev. ##  g        (Intercept) 9.88344  3.1438   ##  g.1      x           0.03541  0.1882   ##  g.2      z           0.00000  0.0000   ##  Residual             1.00309  1.0015   ## Number of obs: 10000, groups:  g, 26 ##  ## Fixed effects: ##             Estimate Std. Error t value ## (Intercept)  3.12330    1.23338   2.532 ## x            2.08221    0.08149  25.550 ## z            3.01461    0.03466  86.967 ##  ## Correlation of Fixed Effects: ##   (Intr) x      ## x -0.006        ## z -0.014  0.000 ##  ## Group memberships per observation for multiple membership REs: ##   Min. per obs. Mean per obs. Max. per obs. ## g 2             2             2"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/group_membership.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info:","title":"Group membership models using lmerMultiMember","text":"","code":"sessionInfo() ## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] Matrix_1.5-4.1         ggplot2_3.4.4          broom.mixed_0.2.9.4    ## [4] lmerMultiMember_0.11.8 ##  ## loaded via a namespace (and not attached): ##  [1] future_1.33.0     sass_0.4.7        utf8_1.2.3        generics_0.1.3    ##  [5] tidyr_1.3.0       stringi_1.7.12    lattice_0.21-8    listenv_0.9.0     ##  [9] lme4_1.1-34       digest_0.6.33     magrittr_2.0.3    evaluate_0.22     ## [13] grid_4.3.1        fastmap_1.1.1     rprojroot_2.0.3   jsonlite_1.8.7    ## [17] backports_1.4.1   purrr_1.0.2       fansi_1.0.5       scales_1.2.1      ## [21] codetools_0.2-19  textshaping_0.3.7 jquerylib_0.1.4   cli_3.6.1         ## [25] rlang_1.1.1       parallelly_1.36.0 munsell_0.5.0     splines_4.3.1     ## [29] withr_2.5.1       cachem_1.0.8      yaml_2.3.7        parallel_4.3.1    ## [33] tools_4.3.1       memoise_2.0.1     nloptr_2.0.3      minqa_1.2.6       ## [37] dplyr_1.1.3       colorspace_2.1-0  forcats_1.0.0     globals_0.16.2    ## [41] boot_1.3-28.1     broom_1.0.5       vctrs_0.6.4       R6_2.5.1          ## [45] lifecycle_1.0.3   stringr_1.5.0     fs_1.6.3          MASS_7.3-60       ## [49] furrr_0.3.1       ragg_1.2.6        pkgconfig_2.0.3   desc_1.4.2        ## [53] gtable_0.3.4      pkgdown_2.0.7     bslib_0.5.1       pillar_1.9.0      ## [57] glue_1.6.2        Rcpp_1.0.11       systemfonts_1.0.5 xfun_0.40         ## [61] tibble_3.2.1      tidyselect_1.2.0  knitr_1.44        farver_2.1.1      ## [65] htmltools_0.5.6.1 nlme_3.1-162      labeling_0.4.3    rmarkdown_2.25    ## [69] compiler_4.3.1"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"introduction-to-multiple-membership-models","dir":"Articles","previous_headings":"","what":"Introduction to multiple membership models","title":"Introduction to lmerMultiMember","text":"vignette walk lmerMultiMember analysis dataset included package. contains examples specifying fitting lmerMultiMember model examples using package’s helper functions, including functions creating multiple membership indicator matrices, creating Bradley-Terry/adversarial indicator matrices, creating interaction/nested multiple membership matrices. Basic understanding generalized linear mixed-effects model (GLMM) assumed; like learn GLMMs can refer lme4 vignettes.","code":"# load a few packages that we will be using a lot library(lmerMultiMember)  # for dataset and modeling library(kableExtra)  # for displaying tabular data library(dplyr)  # for data manipulation library(ggplot2)  # for general plotting stuff  # there are a few packages used in this vignette that are not loaded here # we will just call their functions using the :: operator as needed"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"doubles-tennis-data","dir":"Articles","previous_headings":"","what":"Doubles tennis data","title":"Introduction to lmerMultiMember","text":"vignette ’ll try identify best male doubles tennis player 2010s. tricky question, pair players plays another pair players, determining individual contribution player outcome straightforward. However, can use multiple membership model get measure player’s individual contribution team’s doubles success. Tennis scores somewhat inconvenient outcome model, number points scored opponent good measure player performance. Men’s doubles matches played best--three best--five format, meaning first team two three sets wins. win set, team win six games, lead least two games. win game, team score four points, least two point lead.1 modeling score somewhat thorny problem, tutorial oversimplify little bit instead model match wins losses, can simple binomial GLMM (Generalized Linear Mixed-effects Model). can write model follows: \\[ \\operatorname{logit}(P(win)) = X\\beta + Zu \\] \\(X\\) (dense) matrix fixed effects predictors \\(\\beta\\) vector fixed effects coefficients. \\(Z\\) (sparse) matrix random effects indicators \\(u\\) vector random effects (’re using logit-link convert probabilities). traditional mixed-effects model, sparse indicator matrix \\(Z\\) random effect exactly 1 indicator per observation, look like : \\[ Z = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\] indicator matrix multiple membership model can multiple indicators per case: \\[ Z = \\begin{bmatrix} 1 & 1 & 0 & 0 \\\\ 0 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\] generally, can specify arbitrary indicator weight matrices random effects, including fractional weights negative weights/indicators (class model known Bradley-Terry models): \\[ Z = \\begin{bmatrix} 1 & -1 & 0 & 0 \\\\ 0 & 1 & -1 & 0 \\\\ 0 & 0 & 1 & -1 \\\\ -1 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\] vignette ’ll use three kinds indicator matrices see best model doubles tennis dataset. results ATP men’s doubles tennis matches 2010 2019, compiled Jeff Sackmann. dataset included lmerMultiMember, package installed can load play around .","code":"# load ATP doubles data from package data(\"atp_doubles\", package = \"lmerMultiMember\")  # display the first 1000 matches in the ATP doubles dataset atp_doubles %>%   head(1000) %>%   kable() %>%   kable_styling(bootstrap_options = c(\"hover\", \"condensed\"), font_size = 16) %>%   scroll_box(height = \"250px\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"modeling-player-strength-for-players-on-team-1","dir":"Articles","previous_headings":"","what":"Modeling player strength for players on team 1","title":"Introduction to lmerMultiMember","text":"figure player strongest, ’ll model player effects using multiple membership random intercepts. lmerMultiMember provides helper function generates indicator matrix columns dataframe. illustrate mean , ’ll generate indicator matrix Wt players team 1 first five matches dataset plot .  can see, indicator matrix 1s (filled squares) players match, 0s (empty space) everywhere else. two players team 1 match, row/match matrix, ’ll find two filled squares. Next, generate indicator matrix Wp players team 1 across matches dataset fit GLMM predict match winners indicator matrix. explicitly set global intercept 0, shouldn’t systematic advantage team 1 team 2 model whole dataset.2 model summary tells us model fitted multiple membership model, line bottom shows us minimum, mean, maximum number team 1 players per match 2, expected. view strongest players according model, can extract random intercepts plot . intercepts log odds ratio scale, ’re relatively easy interpret purposes: strongest player largest intercept value.  simple sanity check model see whether players top 10 actually accomplished doubles players. ! Bob Mike Bryan widely considered best men’s doubles team time. end 2010s longer prime, model puts top 10 2010s men’s doubles players ’s good sign ’re capturing player variance correctly.","code":"# generate sparse matrix for small bit of the dataset Wt <- weights_from_columns(atp_doubles[1:5, c(\"team1_player1_name\",                                               \"team1_player2_name\")])  # display matrix plot of the indicator matrix matplot <- plot_membership_matrix(Wt) update(matplot, xlab = \"Team 1 players\", ylab = \"Match\",        at = c(-1.001, .5, 1.001), col.regions = c(\"white\", \"coral1\")) # generate sparse indicator matrix for whole dataset Wp <- weights_from_columns(atp_doubles[, c(\"team1_player1_name\",                                            \"team1_player2_name\")])  # fit GLMM m1 <- glmer(team1_win ~ 0 + (1 | team1_player),             family = \"binomial\", memberships = list(team1_player = Wp),             data = atp_doubles)  # display model summary summary(m1) ## Generalized linear mixed model fit by maximum likelihood (Laplace ##   Approximation). Model includes multiple membership random effects. [ ## glmerModMultiMember] ##  Family: binomial  ( logit ) ## Formula: team1_win ~ 0 + (1 | team1_player) ##    Data: atp_doubles ##  ##      AIC      BIC   logLik deviance df.resid  ##  17742.3  17749.8  -8870.1  17740.3    13037  ##  ## Scaled residuals:  ##      Min       1Q   Median       3Q      Max  ## -1.71911 -0.99037  0.04637  0.91606  1.75388  ##  ## Random effects: ##  Groups       Name        Variance Std.Dev. ##  team1_player (Intercept) 0.09373  0.3062   ## Number of obs: 13038, groups:  team1_player, 858 ##  ## Group memberships per observation for multiple membership REs: ##              Min. per obs. Mean per obs. Max. per obs. ## team1_player 2             2             2 # extract random effects m1_ranefs <- broom.mixed::tidy(m1, effects = \"ran_vals\", conf.int = TRUE) %>%   .[.$group == \"team1_player\", ] %>%   .[order(.$estimate, decreasing = TRUE), ]  # plot top 10 m1_ranefs[1:10, ] %>%   ggplot(aes(x = estimate, y = factor(level, level = level))) +   geom_point(size = 3, color = \"coral1\") +   geom_linerange(aes(xmin = conf.low, xmax = conf.high),                  size = 1, color = \"coral1\") +   theme_bw() + xlab(\"\") + ylab(\"\") +   ggtitle(\"Increase in log(odds ratio) associated with player\") +   theme(axis.ticks = element_blank(),         axis.text.x = element_text(size = 12, angle = 60, hjust = 1.0),         axis.text.y = element_text(size = 12),         plot.title = element_text(size = 14),         rect = element_rect(fill = \"transparent\")) +   scale_y_discrete(limits = rev) +   geom_vline(xintercept = 0, color = \"coral2\", size = 1.0) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated."},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"modeling-player-strength-for-players-on-both-teams","dir":"Articles","previous_headings":"","what":"Modeling player strength for players on both teams","title":"Introduction to lmerMultiMember","text":"One important drawback ’ve modeled player effects model ’re considering team 1 players, team 2. Tennis matches played random replacement-level opponent, ’re played real team can vary strength. means losing Bob Mike Bryan probably harm personal player strength estimate much losing random team , modeling approach account . (course another drawback approach ’re essentially ignoring half available data player strength.) account team 2 player strength, enter team 2 another random intercept, ’s preferable integrate team 2 player strength estimates team 1 player strength estimates. Many players dataset occur members team 1 members team 2, ’ll want make sure share information player strength estimates across estimates teams. One way pool player strength estimates across teams model single random intercept per player, putting negative indicator/weight random intercept player team 2 (.e. player working team 1 winning, event modeling probability!). pools information player strength across players’ appearances teams, shrink uncertainty around estimates.  small part new indicator matrix. Positive indicators still colored orange (coral, actually), new negative indicators colored blue. two teams two players, four filled squares per row/match, 2 orange 2 blue squares. use new indicator matrix lmerMultiMember model, model becomes type Bradley-Terry model, class models predicts win probabilities competing items drawn single pool (players, case). may noticed multiple membership summary line bottom summary now indicates min, mean, max 0 observations. Bradley-Terry style adversarial effects model, indicators team 1 team 2 cancel (.e. indicators team 1 +1, whereas indicators team 2 -1). looks little funny summary, ’s actually quite easy tell specified Bradley-Terry model correctly indicators always sum zero!  can see, modeling team 2 player variability conjunction team 1 player variability using Bradley-Terry style model shrunk uncertainty around estimates player strength, reflecting higher level confidence estimates. can confirm intuition model fits better comparing log-likelihoods models. Model 2 makes better within-sample predictions, demonstrated lower log-likelihood, importantly number parameters (Df column summary shows 0, difference degrees freedom). add random effects model 1 produce model 2, simply using random intercepts sensibly.","code":"# generate indicator matrices for both teams for part of the dataset Wp1 <- weights_from_columns(atp_doubles[1:5, c(\"team1_player1_name\",                                             \"team1_player2_name\")]) Wp2 <- weights_from_columns(atp_doubles[1:5, c(\"team2_player1_name\",                                             \"team2_player2_name\")])  # create a Bradley-Terry/adversarial indicator matrix Wp <- bradleyterry_from_sparse(Wp1, Wp2)  # display matrix plot of the indicator matrix matplot <- plot_membership_matrix(Wp) cmap <- colorRampPalette(c(\"#6495ed\", \"white\", \"coral1\"))(100) matplot$legend$right$args$key$col <- cmap update(matplot, xlab = \"Players\", ylab = \"Match\",        at = seq(-1.001, 1.001, length.out = 100),        col.regions = cmap) # generate sparse indicator matrices for both teams Wp1 <- weights_from_columns(atp_doubles[, c(\"team1_player1_name\",                                             \"team1_player2_name\")]) Wp2 <- weights_from_columns(atp_doubles[, c(\"team2_player1_name\",                                             \"team2_player2_name\")])  # create a Bradley-Terry/adversarial indicator matrix Wp <- bradleyterry_from_sparse(Wp1, Wp2)  # fit GLMM m2 <- glmer(team1_win ~ 0 + (1 | player),             family = \"binomial\", memberships = list(player = Wp),             data = atp_doubles)  # display model summary summary(m2) ## Generalized linear mixed model fit by maximum likelihood (Laplace ##   Approximation). Model includes multiple membership random effects. [ ## glmerModMultiMember] ##  Family: binomial  ( logit ) ## Formula: team1_win ~ 0 + (1 | player) ##    Data: atp_doubles ##  ##      AIC      BIC   logLik deviance df.resid  ##  16688.3  16695.8  -8343.1  16686.3    13037  ##  ## Scaled residuals:  ##      Min       1Q   Median       3Q      Max  ## -2.98010 -0.84939  0.00367  0.85098  2.85597  ##  ## Random effects: ##  Groups Name        Variance Std.Dev. ##  player (Intercept) 0.1903   0.4363   ## Number of obs: 13038, groups:  player, 992 ##  ## Group memberships per observation for multiple membership REs: ##        Min. per obs. Mean per obs. Max. per obs. ## player 0             0             0 # extract random effects m2_ranefs <- broom.mixed::tidy(m2, effects = \"ran_vals\", conf.int = TRUE) %>%   .[.$group == \"player\", ] %>%   .[order(.$estimate, decreasing = TRUE), ]  # plot top 10 m2_ranefs[1:10, ] %>%   ggplot(aes(x = estimate, y = factor(level, level = level))) +   geom_point(size = 3, color = \"coral1\") +   geom_linerange(aes(xmin = conf.low, xmax = conf.high),                  size = 1, color = \"coral1\") +   theme_bw() + xlab(\"\") + ylab(\"\") +   ggtitle(\"Increase in log(odds ratio) associated with player\") +   theme(axis.ticks = element_blank(),         axis.text.x = element_text(size = 12, angle = 60, hjust = 1.0),         axis.text.y = element_text(size = 12),         plot.title = element_text(size = 14),         rect = element_rect(fill = \"transparent\")) +   scale_y_discrete(limits = rev) +   geom_vline(xintercept = 0, color = \"coral2\", size = 1.0) lmtest::lrtest(m1, m2) ## Likelihood ratio test ##  ## Model 1: team1_win ~ 0 + (1 | team1_player) ## Model 2: team1_win ~ 0 + (1 | player) ##   #Df  LogLik Df Chisq Pr(>Chisq)     ## 1   1 -8870.1                         ## 2   1 -8343.1  0  1054  < 2.2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 anova(m1, m2) ## Data: atp_doubles ## Models: ## m1: team1_win ~ 0 + (1 | team1_player) ## m2: team1_win ~ 0 + (1 | player) ##    npar   AIC   BIC  logLik deviance Chisq Df Pr(>Chisq) ## m1    1 17742 17750 -8870.1    17740                     ## m2    1 16688 16696 -8343.1    16686  1054  0"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"using-nestedinteraction-multiple-membership-to-find-the-player-with-the-strongest-year-of-the-2010s","dir":"Articles","previous_headings":"","what":"Using nested/interaction multiple membership to find the player with the strongest year of the 2010s","title":"Introduction to lmerMultiMember","text":"Players don’t maintain single level performance across whole career. tend start weaker, peak, fall eventually retire. players retire soon peak, others keep playing lower level performance many years. model account change player performance time, can add year match played random effects structure. let us identify players strongest years play 2010s. ’ll use Matrix::fac2sparse() generate indicator matrix years, use lmerMultiMember::interaction_weights() helper function create sparse indicator matrix interaction year player random effects.  plot data like , can see player single strongest year tennis 2010s Marcelo Melo 2015, Bryans’ 2013 performance close second.3 estimates pass simple sanity checks: Marcelo Melo, example, reached number 1 spot ATP men’s doubles ranking 2015, fits successful season. Likewise, Bryans ranked number 1 ATP men’s doubles ranking 2013. uncertainty intervals estimates larger intervals whole-decade strength estimates player. previous model ten times observations/matches per player, increase uncertainty expected.","code":"# get year in which tournament was played atp_doubles$year <- substr(atp_doubles$tourney_date, 1, 4)  # create sparse matrix from years Wy <- Matrix::fac2sparse(atp_doubles$year)  # generate sparse interaction matrix from sparse player and year matrices Wpy <- interaction_weights(Wp, Wy)  # fit model m3 <- glmer(team1_win ~ 0 + (1 | playerXyear),             family = \"binomial\", memberships = list(playerXyear = Wpy),             data = atp_doubles)  # print model summary summary(m3) ## Generalized linear mixed model fit by maximum likelihood (Laplace ##   Approximation). Model includes multiple membership random effects. [ ## glmerModMultiMember] ##  Family: binomial  ( logit ) ## Formula: team1_win ~ 0 + (1 | playerXyear) ##    Data: atp_doubles ##  ##      AIC      BIC   logLik deviance df.resid  ##  17297.1  17304.6  -8647.5  17295.1    13037  ##  ## Scaled residuals:  ##      Min       1Q   Median       3Q      Max  ## -3.14747 -0.84233 -0.01485  0.85261  2.37473  ##  ## Random effects: ##  Groups      Name        Variance Std.Dev. ##  playerXyear (Intercept) 0.2066   0.4546   ## Number of obs: 13038, groups:  playerXyear, 9920 ##  ## Group memberships per observation for multiple membership REs: ##             Min. per obs. Mean per obs. Max. per obs. ## playerXyear 0             0             0 # extract random effects m3_ranefs <- broom.mixed::tidy(m3, effects = \"ran_vals\", conf.int = TRUE) %>%   .[.$group == \"playerXyear\", ] %>%   .[order(.$estimate, decreasing = TRUE), ] %>%   mutate(level = gsub(\"\\\\.\", \" in \", level))  # plot top 10 m3_ranefs[1:10, ] %>%   ggplot(aes(x = estimate, y = factor(level, level = level))) +   geom_point(size = 3, color = \"coral1\") +   geom_linerange(aes(xmin = conf.low, xmax = conf.high),                  size = 1, color = \"coral1\") +   theme_bw() + xlab(\"\") + ylab(\"\") +   ggtitle(\"Increase in log(odds ratio) associated with player\") +   theme(axis.ticks = element_blank(),         axis.text.x = element_text(size = 12, angle = 60, hjust = 1.0),         axis.text.y = element_text(size = 12),         plot.title = element_text(size = 14),         rect = element_rect(fill = \"transparent\")) +   scale_y_discrete(limits = rev) +   geom_vline(xintercept = 0, color = \"coral2\", size = 1.0)"},{"path":"https://jvparidon.github.io/lmerMultiMember/articles/lmermultimember_intro.html","id":"some-final-notes","dir":"Articles","previous_headings":"","what":"Some final notes","title":"Introduction to lmerMultiMember","text":"vignette intended template tutorial using lmerMultiMember. intended definitive analysis tennis player performance. many factors one might want consider modeling tennis matches, ’s obviously beyond scope vignette. questions notes, feel free reach authors. find error bug, please file issue Github repository. want get practice package, one exercise suggest try modifying code last model identify strongest player surface (clay, grass, hardcourt) instead strongest player year.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"JP van Paridon. Author, maintainer. Ben Bolker. Author. Phillip Alday. Author.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"van Paridon J, Bolker B, Alday P (2023). lmerMultiMember: Multiple membership random effects. R package version 0.11.8, https://jvparidon.github.io/lmerMultiMember/.","code":"@Manual{,   title = {lmerMultiMember: Multiple membership random effects},   author = {JP {van Paridon} and Ben Bolker and Phillip Alday},   year = {2023},   note = {R package version 0.11.8},   url = {https://jvparidon.github.io/lmerMultiMember/}, }"},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"lmermultimember-","dir":"","previous_headings":"","what":"Multiple membership random effects","title":"Multiple membership random effects","text":"Wrapper around lme4::lmer lme4::glmer add support multiple membership random effects.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Multiple membership random effects","text":"package yet available CRAN, can install devtools package:","code":"if(!require(devtools)){     install.packages(\"devtools\")     library(\"devtools\") }  install_github(\"jvparidon/lmerMultiMember\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"how-to-use-lmermultimember","dir":"","previous_headings":"","what":"How to use lmerMultiMember","title":"Multiple membership random effects","text":"want learn use lmerMultiMember, good start finish reading README. , can check package vignettes information specific topics: General introduction multiple membership models Bradley-Terry models lmerMultiMember original multiple membership vignette (Ben Bolker’s worked example inspired package) Frequently Asked Questions","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"what-is-a-multimembership-random-effect","dir":"","previous_headings":"","what":"What is a multimembership random effect?","title":"Multiple membership random effects","text":"Let’s take authorship example: want model aspect published journal articles, e.g. citations ~ word_count, might want account variability caused authors papers using random intercepts. However, many papers don’t just single author. account author variability ? One method model unique grouping authors separate level random effect (.e. “John ”, “Mary B”, “John & Mary B”, “Mary B & John ” four different levels random effect) downside correctly attributing variance individual authors groups. Another option separate random effects position author list (.e. (1|author1) + (1|author2) + (1|author3) etc.) treat author separate entity, treats author different people depending occur author list, also little strange. natural option associate observation (journal article) multiple levels (authors) single random effect. multimembership random effect.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"how-to-specify-a-multimembership-random-effect","dir":"","previous_headings":"","what":"How to specify a multimembership random effect","title":"Multiple membership random effects","text":"Specifying multimembership model lmerMultiMember works just like specifying mixed effects model lme4, addition membership matrix (weight matrix). sparse matrix contains rows observations dataset columns unique group member. observation, matrix contains 1s group members associated , 0s everywhere else. (group members equal association strength, 1s membership matrix can, principle, replaces fractions represent relative contributions, etc.) model syntax e.g. lmerMultiMember::lmer(citations ~ word_count + (1 | author), memberships = list(author = membership_matrix)). Creating membership matrix might seem little daunting, provide helper function lmerMultiMember::weights_from_vector creates membership matrix vector group memberships comma-separated strings (e.g. c(\",B\", \",B,C\", \"B\", \"C,\")) group memberships documented dataset easy enough create membership matrix model.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"nested-random-effects-groupings-work-a-little-differently","dir":"","previous_headings":"","what":"Nested random effects groupings work a little differently","title":"Multiple membership random effects","text":"lmerMultiMember uses dummy variables fake factors internally ‘trick’ lme4 accepting multiple membership random effects. Unfortunately, system dummies fakes means can’t specify nested multimembership random effects grouping using normal formula syntax. example, lmer(citations ~ word_count + (1 | journal/author), memberships = list(author = membership_matrix)) throw error, multiple membership author variable nested inside journal grouping. solution issue pre-generate indicator/weight matrix nested grouping using provided lmerMultiMember::interaction_weights() function. example, given dataframe df multimembership author single membership journal grouping variables, order get nested groupings, following:","code":"Wa <- weights_from_vectors(df$author) Wj <- Matrix::fac2sparse(df$journal)  # convert single membership vars to an indicator matrix with fac2sparse() Waj <- interaction_weights(Wa, Wj) lmer(citations ~ word_count + (1 | journal) + (1 | authorXjournal), memberships = list(authorXjournal = Waj))"},{"path":"https://jvparidon.github.io/lmerMultiMember/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Multiple membership random effects","text":"issues fitting models lmerMultiMember, feel free contact JP van Paridon vanparidon@wisc.edu. find error bug, please file issue Github repository.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/atp_doubles.html","id":null,"dir":"Reference","previous_headings":"","what":"ATP men's doubles tennis matches from the 2010 to 2019 — atp_doubles","title":"ATP men's doubles tennis matches from the 2010 to 2019 — atp_doubles","text":"subset ATP men's doubles tennis data compiled Jeff Sackmann, released CC--NC-SA license reproduced attribution.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/atp_doubles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ATP men's doubles tennis matches from the 2010 to 2019 — atp_doubles","text":"","code":"atp_doubles"},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/atp_doubles.html","id":"atp-doubles","dir":"Reference","previous_headings":"","what":"atp_doubles","title":"ATP men's doubles tennis matches from the 2010 to 2019 — atp_doubles","text":"data frame 13038 rows 47 columns: tourney_id Unique identifier tournamens tourney_name Name tournament surface Surface match played draw_size ??? tourney_level ??? tourney_date Date tournament started match_num ??? score Scores per set best_of Maximum number sets, either best--3 best--5 round Round tournament match played team1_win 1 team 1 won, 0 team 2 won team1_player1_id, team1_player2_id, team2_player1_id, team2_player2_id Unique identifier player team team1_seed, team2_seed Position team seeded team1_entry, team2_entry ??? team1_player1_name, team1_player2_name, team2_player1_name, team2_player2_name Name player team team1_player1_hand, team1_player2_hand, team2_player1_hand, team2_player2_hand Handedness player team team1_player1_ht, team1_player2_ht, team2_player1_ht, team2_player2_ht Height cm player team team1_player1_ioc, team1_player2_ioc, team2_player1_ioc, team2_player2_ioc IOC player team competes team1_player1_age, team1_player2_age, team2_player1_age, team2_player2_age Age player team team1_player1_rank, team1_player2_rank, team2_player1_rank, team2_player2_rank ATP ranking player team team1_player1_rank_points, team1_player2_rank_points, team2_player1_rank_points, team2_player2_rank_points ???","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/atp_doubles.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"ATP men's doubles tennis matches from the 2010 to 2019 — atp_doubles","text":"https://github.com/JeffSackmann/tennis_atp","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","title":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","text":"Provides helper function generating indicator matrices","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","text":"","code":"bradleyterry_from_sparse(winners, losers)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","text":"winners sparse matrix containing winner observation losers sparse matrix containing loser observation","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","text":"sparse Bradley-Terry indicator matrix type Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_sparse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Indicator matrix from two sparse matrices for Bradley-Terry models — bradleyterry_from_sparse","text":"","code":"winners <- Matrix::fac2sparse(c(\"k\", \"k\", \"l\", \"m\", \"m\")) losers <- Matrix::fac2sparse(c(\"l\", \"m\", \"m\", \"k\", \"l\")) Wwl <- bradleyterry_from_sparse(winners, losers)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","title":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","text":"Provides helper function generating indicator matrices","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","text":"","code":"bradleyterry_from_vectors(winners, losers)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","text":"winners vector strings containing winner observation losers vector strings containing loser observation","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","text":"sparse Bradley-Terry indicator matrix type Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/bradleyterry_from_vectors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Indicator matrix from two vectors for Bradley-Terry models — bradleyterry_from_vectors","text":"","code":"winners <- c(\"k\", \"k\", \"l\", \"m\", \"m\") losers <- c(\"l\", \"m\", \"m\", \"k\", \"l\") Wwl <- bradleyterry_from_vectors(winners, losers)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmer.html","id":null,"dir":"Reference","previous_headings":"","what":"multimembership generalized linear mixed effects models — glmer","title":"multimembership generalized linear mixed effects models — glmer","text":"lme4::glmer multimembership random effects","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"multimembership generalized linear mixed effects models — glmer","text":"","code":"glmer(   formula,   data = NULL,   family,   control = lme4::glmerControl(),   start = NULL,   verbose = 0L,   nAGQ = 1L,   weights = NULL,   na.action = na.omit,   offset = NULL,   contrasts = NULL,   devFunOnly = FALSE,   memberships = NULL )"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"multimembership generalized linear mixed effects models — glmer","text":"formula two-sided linear formula object describing     fixed-effects random-effects part model, response     left ~ operator terms, separated     + operators, right.  Random-effects terms     distinguished vertical bars (\"|\") separating expressions     design matrices grouping factors. data optional data frame containing variables named     formula.  default variables taken     environment lmer called.  data     optional, package authors strongly recommend use,     especially later applying methods update     drop1 fitted model (methods     guaranteed work properly data omitted).      data omitted, variables taken environment     formula (specified formula) parent     frame (specified character vector). family GLM family, see glm     family. control list (correct class, resulting     lmerControl() glmerControl()     respectively) containing control parameters, including nonlinear     optimizer used parameters passed     nonlinear optimizer, see *lmerControl documentation     details. start named list starting values parameters     model, numeric vector.  numeric start argument     used starting value theta.  start     list, theta element (numeric vector) used     starting value first optimization step (default=1     diagonal elements 0 -diagonal elements lower     Cholesky factor); fitted value theta first     step, plus start[[\"fixef\"]], used starting values     second optimization step.  start fixef     theta elements, first optimization step skipped.     details finer control optimization, see     modular. verbose integer scalar.  > 0 verbose output     generated optimization parameter estimates.      > 1 verbose output generated individual     penalized iteratively reweighted least squares (PIRLS) steps. nAGQ integer scalar - number points per axis     evaluating adaptive Gauss-Hermite approximation     log-likelihood.  Defaults 1, corresponding Laplace     approximation.  Values greater 1 produce greater accuracy     evaluation log-likelihood expense speed.      value zero uses faster less exact form parameter     estimation GLMMs optimizing random effects     fixed-effects coefficients penalized iteratively reweighted     least squares step. (See Details.) weights optional vector ‘prior weights’ used       fitting process.  NULL numeric       vector. na.action function indicates happen     data contain NAs.  default action (na.omit,     inherited ‘factory fresh’ value     getOption(\"na.action\")) strips observations     missing values variables. offset can used specify priori known     component included linear predictor     fitting. NULL numeric vector length     equal number cases.  One offset     terms can included formula instead well,     one specified sum used.  See model.offset. contrasts optional list.  See contrasts.arg     model.matrix.default. devFunOnly logical - return deviance evaluation     function. Note deviance function operates     variables stored environment, may return     exactly values subsequent calls (results     always within machine tolerance). memberships named list weight matrices replace (dummy) random effects matching names","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"multimembership generalized linear mixed effects models — glmer","text":"lme4 model object","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"multimembership generalized linear mixed effects models — glmer","text":"","code":"df <- data.frame(   x = runif(60, 0, 1),   y = rbinom(60, 1, 0.6),   memberships = rep(c(\"a,b,c\", \"a,c\", \"a\", \"b\", \"b,a\", \"b,c,a\"), 10) ) weights <- weights_from_vector(df$memberships)  # note that the grouping variable name is arbitrary -- it just has # to match the name in the list and doesn't need to correspond to a column # name in the data glmer(y ~ x + (1 | members),   data = df,   family = binomial,   memberships = list(members = weights) ) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerModMultiMember] #>  Family: binomial  ( logit ) #> Formula: y ~ x + (1 | members) #>    Data: df #>      AIC      BIC   logLik deviance df.resid  #>  83.4162  89.6992 -38.7081  77.4162       57  #> Random effects: #>  Groups  Name        Std.Dev. #>  members (Intercept) 0        #> Number of obs: 60, groups:  members, 3 #> Fixed Effects: #> (Intercept)            x   #>      0.3690       0.4972"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmerModMultiMember-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Model object for multimembership generalized linear mixed models — glmerModMultiMember-class","title":"Model object for multimembership generalized linear mixed models — glmerModMultiMember-class","text":"glmerModMultiMember class extends glmerMod lme4-package merModMultiMember.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/glmerModMultiMember-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model object for multimembership generalized linear mixed models — glmerModMultiMember-class","text":"object class glmerModMultiMember similar merModMultiMember objects inheriting glmerMod","code":""},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/interaction_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight matrix from the interaction of two other weight matrices — interaction_weights","title":"Weight matrix from the interaction of two other weight matrices — interaction_weights","text":"Provides helper function pre-generating interactions. Takes sparse weight/indicator matrices generated e.g. Matrix::fac2sparse() weights_from_vector() input.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/interaction_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight matrix from the interaction of two other weight matrices — interaction_weights","text":"","code":"interaction_weights(a, b)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/interaction_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight matrix from the interaction of two other weight matrices — interaction_weights","text":"sparse weight/indicator matrix class Matrix::dgCMatrix b sparse weight/indicator matrix class Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/interaction_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weight matrix from the interaction of two other weight matrices — interaction_weights","text":"sparse interaction weight/indicator matrix class Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/interaction_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weight matrix from the interaction of two other weight matrices — interaction_weights","text":"","code":"a <- rep(c(\"k\", \"l\", \"l,k\"), 2) b <- rep(c(\"m\", \"n\"), 3) Wa <- weights_from_vector(a) Wb <- Matrix::fac2sparse(b) Wab <- interaction_weights(Wa, Wb)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmer.html","id":null,"dir":"Reference","previous_headings":"","what":"multimembership linear mixed effects models — lmer","title":"multimembership linear mixed effects models — lmer","text":"lme4::lmer multimembership random effects","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"multimembership linear mixed effects models — lmer","text":"","code":"lmer(   formula,   data = NULL,   REML = TRUE,   control = lme4::lmerControl(),   start = NULL,   verbose = 0L,   weights = NULL,   na.action = na.omit,   offset = NULL,   contrasts = NULL,   devFunOnly = FALSE,   memberships = NULL )"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"multimembership linear mixed effects models — lmer","text":"formula two-sided linear formula object describing     fixed-effects random-effects part model,     response left ~ operator terms, separated     + operators, right.  Random-effects terms     distinguished vertical bars (|) separating expressions     design matrices grouping factors.  Two vertical bars     (||) can used specify multiple uncorrelated random     effects grouping variable.      (way implemented, ||-syntax works        design matrices containing numeric (continuous) predictors;      fit models independent categorical effects, see dummy      lmer_alt function afex package.) data optional data frame containing variables named     formula.  default variables taken     environment lmer called. data     optional, package authors strongly recommend use,     especially later applying methods update     drop1 fitted model (methods     guaranteed work properly data omitted).     data omitted, variables taken environment     formula (specified formula) parent     frame (specified character vector). REML logical scalar - estimates chosen     optimize REML criterion (opposed log-likelihood)? control list (correct class, resulting     lmerControl() glmerControl()     respectively) containing control parameters, including nonlinear     optimizer used parameters passed     nonlinear optimizer, see *lmerControl documentation     details. start named list starting values     parameters model.  lmer can numeric     vector list one component named \"theta\". verbose integer scalar.  > 0 verbose output     generated optimization parameter estimates.      > 1 verbose output generated individual     penalized iteratively reweighted least squares (PIRLS) steps. weights optional vector ‘prior weights’ used     fitting process.  NULL numeric vector.     Prior weights normalized standardized     way.  particular, diagonal residual covariance     matrix squared residual standard deviation parameter     sigma times vector inverse weights.     Therefore, weights relatively large magnitudes,     order compensate, sigma parameter     also need relatively large magnitude. na.action function indicates happen     data contain NAs.  default action (na.omit,     inherited 'factory fresh' value     getOption(\"na.action\")) strips observations     missing values variables. offset can used specify priori known     component included linear predictor     fitting. NULL numeric vector length     equal number cases.  One offset     terms can included formula instead well,     one specified sum used.  See     model.offset. contrasts optional list. See contrasts.arg     model.matrix.default. devFunOnly logical - return deviance evaluation     function. Note deviance function operates     variables stored environment, may return     exactly values subsequent calls (results     always within machine tolerance). memberships named list weight matrices replace (dummy) random effects matching names","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"multimembership linear mixed effects models — lmer","text":"lme4 model object","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"multimembership linear mixed effects models — lmer","text":"","code":"df <- data.frame(   x = seq(60) + runif(60, 0, 10),   y = seq(60) + rep(runif(6, 0, 10), 10),   memberships = rep(c(\"a,b,c\", \"a,c\", \"a\", \"b\", \"b,a\", \"b,c,a\"), 10) ) weights <- weights_from_vector(df$memberships)  # note that the grouping variable name is arbitrary -- it just has # to match the name in the list and doesn't need to correspond to a column # name in the data lmer(y ~ x + (1 | members),   data = df,   memberships = list(members = weights) ) #> Linear mixed model fit by REML ['lmerModMultiMember'] #> Formula: y ~ x + (1 | members) #>    Data: df #> REML criterion at convergence: 334.1473 #> Random effects: #>  Groups   Name        Std.Dev.  #>  members  (Intercept) 4.081e-07 #>  Residual             3.827e+00 #> Number of obs: 60, groups:  members, 3 #> Fixed Effects: #> (Intercept)            x   #>     -0.2640       0.9876"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmerModLmerTestMultiMember-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Model object for multimembership linear mixed models with lmerTest — lmerModLmerTestMultiMember-class","title":"Model object for multimembership linear mixed models with lmerTest — lmerModLmerTestMultiMember-class","text":"lmerModMultiMember class extends lmerModLmerTest lmerTest-package lmerModMultiMember.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmerModLmerTestMultiMember-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model object for multimembership linear mixed models with lmerTest — lmerModLmerTestMultiMember-class","text":"object class lmerModMultiMember similar merModMultiMember objects inheriting lmerMod","code":""},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmerModMultiMember-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Model object for multimembership linear mixed models — lmerModMultiMember-class","title":"Model object for multimembership linear mixed models — lmerModMultiMember-class","text":"lmerModMultiMember class extends lmerMod lme4-package merModMultiMember.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/lmerModMultiMember-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model object for multimembership linear mixed models — lmerModMultiMember-class","text":"object class lmerModMultiMember similar merModMultiMember objects inheriting lmerMod","code":""},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/merModMultiMember-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Model object for multimembership linear mixed models — merModMultiMember-class","title":"Model object for multimembership linear mixed models — merModMultiMember-class","text":"merModMultiMember class extends merMod lme4-package.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/merModMultiMember-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model object for multimembership linear mixed models — merModMultiMember-class","text":"object class merModMultiMember similar merMod objects (see merMod) extra information multimembership random effects.","code":""},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/nfl_scores_2021.html","id":null,"dir":"Reference","previous_headings":"","what":"National Football League scores from the 2021 season — nfl_scores_2021","title":"National Football League scores from the 2021 season — nfl_scores_2021","text":"subset NFL scores FiveThirtyEight's football model dataset, released CC-license reproduced attribution.","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/nfl_scores_2021.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"National Football League scores from the 2021 season — nfl_scores_2021","text":"","code":"nfl_scores_2021"},{"path":[]},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/nfl_scores_2021.html","id":"nfl-scores-","dir":"Reference","previous_headings":"","what":"nfl_scores_2021","title":"National Football League scores from the 2021 season — nfl_scores_2021","text":"data frame 285 rows 7 columns: date Date game played season NFL season game played home_team, visiting_team 3-letter codes playing teams home_score, visiting_score Scores playing teams winner Whether home team visiting team won game","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/nfl_scores_2021.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"National Football League scores from the 2021 season — nfl_scores_2021","text":"https://github.com/fivethirtyeight/data/tree/master/nfl-elo","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.dgCMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting function for multiple membership weights histogram — plot_membership_hist.dgCMatrix","title":"Plotting function for multiple membership weights histogram — plot_membership_hist.dgCMatrix","text":"Plotting function multiple membership weights histogram","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.dgCMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting function for multiple membership weights histogram — plot_membership_hist.dgCMatrix","text":"","code":"# S3 method for dgCMatrix plot_membership_hist(x, varname = NULL, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.dgCMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting function for multiple membership weights histogram — plot_membership_hist.dgCMatrix","text":"x multimembership weight matrix varname name multimembership variable, used title ... additional arguments pass graphics::hist","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic for multiple dispatch of multiple membership weights\nhistogram functions — plot_membership_hist","title":"Generic for multiple dispatch of multiple membership weights\nhistogram functions — plot_membership_hist","text":"Generic multiple dispatch multiple membership weights histogram functions","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic for multiple dispatch of multiple membership weights\nhistogram functions — plot_membership_hist","text":"","code":"plot_membership_hist(x, varname = NULL, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic for multiple dispatch of multiple membership weights\nhistogram functions — plot_membership_hist","text":"x object containing multimembership information, either weight matrix, multimembership model, model summary varname multimembership variable plot, object contains one ... additional arguments pass graphics::hist","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting method for multiple memberships model weights histogram — plot_membership_hist.merModMultiMember","title":"Plotting method for multiple memberships model weights histogram — plot_membership_hist.merModMultiMember","text":"Plotting method multiple memberships model weights histogram","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting method for multiple memberships model weights histogram — plot_membership_hist.merModMultiMember","text":"","code":"# S3 method for merModMultiMember plot_membership_hist(x, varname, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting method for multiple memberships model weights histogram — plot_membership_hist.merModMultiMember","text":"x merModMultiMember object varname multimembership variable plotted ... additional arguments pass graphics::hist","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.summary.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting method for multiple memberships model summary weights\nhistogram — plot_membership_hist.summary.merModMultiMember","title":"Plotting method for multiple memberships model summary weights\nhistogram — plot_membership_hist.summary.merModMultiMember","text":"Plotting method multiple memberships model summary weights histogram","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.summary.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting method for multiple memberships model summary weights\nhistogram — plot_membership_hist.summary.merModMultiMember","text":"","code":"# S3 method for summary.merModMultiMember plot_membership_hist(x, varname, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_hist.summary.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting method for multiple memberships model summary weights\nhistogram — plot_membership_hist.summary.merModMultiMember","text":"x merModMultiMember summary object varname multimembership variable plotted ... additional arguments pass graphics::hist","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting function for multiple membership matrix — plot_membership_matrix.default","title":"Plotting function for multiple membership matrix — plot_membership_matrix.default","text":"Plotting function multiple membership matrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting function for multiple membership matrix — plot_membership_matrix.default","text":"","code":"# S3 method for default plot_membership_matrix(x, varname = NULL, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting function for multiple membership matrix — plot_membership_matrix.default","text":"x multimembership weight matrix varname name multimembership variable, used title ... additional arguments pass Matrix::image","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic for multiple dispatch of multiple membership plot functions — plot_membership_matrix","title":"Generic for multiple dispatch of multiple membership plot functions — plot_membership_matrix","text":"Generic multiple dispatch multiple membership plot functions","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic for multiple dispatch of multiple membership plot functions — plot_membership_matrix","text":"","code":"plot_membership_matrix(x, varname = NULL, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic for multiple dispatch of multiple membership plot functions — plot_membership_matrix","text":"x object containing multimembership information, either weight matrix, multimembership model, model summary varname multimembership variable plot, object contains one ... additional arguments pass Matrix::image","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting method for multiple memberships model — plot_membership_matrix.merModMultiMember","title":"Plotting method for multiple memberships model — plot_membership_matrix.merModMultiMember","text":"Plotting method multiple memberships model","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting method for multiple memberships model — plot_membership_matrix.merModMultiMember","text":"","code":"# S3 method for merModMultiMember plot_membership_matrix(x, varname, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting method for multiple memberships model — plot_membership_matrix.merModMultiMember","text":"x merModMultiMember object varname multimembership variable plotted ... additional arguments pass Matrix::image","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.summary.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting method for multiple memberships model summary — plot_membership_matrix.summary.merModMultiMember","title":"Plotting method for multiple memberships model summary — plot_membership_matrix.summary.merModMultiMember","text":"Plotting method multiple memberships model summary","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.summary.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting method for multiple memberships model summary — plot_membership_matrix.summary.merModMultiMember","text":"","code":"# S3 method for summary.merModMultiMember plot_membership_matrix(x, varname, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/plot_membership_matrix.summary.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting method for multiple memberships model summary — plot_membership_matrix.summary.merModMultiMember","text":"x merModMultiMember summary object varname multimembership variable plotted ... additional arguments pass Matrix::image","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.lmerModLmerTestMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for multiple memberships model summary — print.summary.lmerModLmerTestMultiMember","title":"Print method for multiple memberships model summary — print.summary.lmerModLmerTestMultiMember","text":"Print method multiple memberships model summary","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.lmerModLmerTestMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for multiple memberships model summary — print.summary.lmerModLmerTestMultiMember","text":"","code":"# S3 method for summary.lmerModLmerTestMultiMember print(x, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.lmerModLmerTestMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for multiple memberships model summary — print.summary.lmerModLmerTestMultiMember","text":"x merModMultiMember object ... additional arguments passed print.summary.merMod","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for multiple memberships model summary — print.summary.merModMultiMember","title":"Print method for multiple memberships model summary — print.summary.merModMultiMember","text":"Print method multiple memberships model summary","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for multiple memberships model summary — print.summary.merModMultiMember","text":"","code":"# S3 method for summary.merModMultiMember print(x, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/print.summary.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for multiple memberships model summary — print.summary.merModMultiMember","text":"x merModMultiMember object ... additional arguments passed print.summary.merMod","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. lme4 fixef, ranef","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.lmerModLmerTestMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for multimembership model objects — summary.lmerModLmerTestMultiMember","title":"Summary method for multimembership model objects — summary.lmerModLmerTestMultiMember","text":"Summary method multimembership model objects","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.lmerModLmerTestMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for multimembership model objects — summary.lmerModLmerTestMultiMember","text":"","code":"# S3 method for lmerModLmerTestMultiMember summary(object, ..., ddf = \"lme4\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.lmerModLmerTestMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for multimembership model objects — summary.lmerModLmerTestMultiMember","text":"object merModMultiMember model object ... additional arguments passed summary.merMod ddf method computing degrees freedom, used lmerTest","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.lmerModLmerTestMultiMember.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for multimembership model objects — summary.lmerModLmerTestMultiMember","text":"summary merModMultiMember object","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.merModMultiMember.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for multimembership model objects — summary.merModMultiMember","title":"Summary method for multimembership model objects — summary.merModMultiMember","text":"Summary method multimembership model objects","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.merModMultiMember.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for multimembership model objects — summary.merModMultiMember","text":"","code":"# S3 method for merModMultiMember summary(object, ...)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.merModMultiMember.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for multimembership model objects — summary.merModMultiMember","text":"object merModMultiMember model object ... additional arguments passed summary.merMod","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/summary.merModMultiMember.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for multimembership model objects — summary.merModMultiMember","text":"summary merModMultiMember object","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight matrix from columns containing memberships — weights_from_columns","title":"Weight matrix from columns containing memberships — weights_from_columns","text":"Provides helper function generating weight matrices","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight matrix from columns containing memberships — weights_from_columns","text":"","code":"weights_from_columns(membership_columns)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight matrix from columns containing memberships — weights_from_columns","text":"membership_columns columns containing group memberships","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weight matrix from columns containing memberships — weights_from_columns","text":"sparse weight/indicator matrix type Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weight matrix from columns containing memberships — weights_from_columns","text":"","code":"a <- cbind(   c(\"k\", \"k\", \"l\", NA, \"m\"),   c(\"l\", \"m\", \"k\", \"m\", \"k\"),   c(\"m\", NA, \"m\", NA, NA) ) Wa <- weights_from_columns(a)"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight matrix from vector of memberships — weights_from_vector","title":"Weight matrix from vector of memberships — weights_from_vector","text":"Provides helper function generating weight matrices","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight matrix from vector of memberships — weights_from_vector","text":"","code":"weights_from_vector(membership_vector, sep = \",\")"},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight matrix from vector of memberships — weights_from_vector","text":"membership_vector vector strings containing group memberships sep separator delimits group memberships membership_vector","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weight matrix from vector of memberships — weights_from_vector","text":"sparse weight/indicator matrix type Matrix::dgCMatrix","code":""},{"path":"https://jvparidon.github.io/lmerMultiMember/reference/weights_from_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weight matrix from vector of memberships — weights_from_vector","text":"","code":"a <- c(\"k,l,m\", \"k,m\", \"k\", \"l\", \"l,k\") Wa <- weights_from_vector(a)"}]
